<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script type="text/javascript" src="lib/d3.v5.min.js"></script>
<script type="text/javascript" src="lib/d3-dsv.min.js"></script>
<script type="text/javascript" src="lib/d3-legend.min.js"></script>
<script type="text/javascript" src="lib/d3-tip.min.js"></script>
<style type="text/css">

/* Legend Font Style */
body {
	font: 11px sans-serif;
	background-color: floralwhite;
}

/* Legend Position Style */
.legend {
	position:absolute;
	left:20px;
	top:50px;
}

h1 {
  font-size: 20px;
  font-family: 'Helvetica Neue', sans-serif;
  font-weight: bold; letter-spacing: -1px; line-height: 1;
  margin-left: 300px;
}

h2 {
  position: absolute;
  left: 1140px;
  top: 451px;
  font-size: 14px;
}

h3 {
  position: absolute;
  left: 1140px;
  top: 680px;
  font-size: 10px;
}

.axis text {
	font: 10px sans-serif;
}

.axis line, .axis path {
	fill: none;
	stroke: #000;
	shape-rendering: crispEdges;
}
	/* define CSS rules here */
	.d3-tip {
		line-height: 1;
		font-weight: bold;
		padding: 12px;
		background: rgba(0, 0, 0, 0.8);
		color: #fff;
		border-radius: 2px;
		white-space: pre-line;
	}

</style>
</head>
<body>
	<h1>The U.S. Housing Price Forecasting Visualization</h1>
	<p></p>
	<h2>Select the year and number of bedrooms below</h2>
	<h3>Team #4 The Underdogs: William Lusty, Leonardo Calizaya, Matthew Pleskow, Haoxuan Huang, Michael Cho, Jun Hyuk Jeon</h3>
<script type="text/javascript">

//Width and height of map
var margin = {top: 20, right: 20, bottom: 30, left: 50}

var width = 1200 - margin.left - margin.right;
var height = 500 - margin.top - margin.bottom;

var lcwidth = 520 - margin.left - margin.right
var lcheight = 190 - margin.top - margin.bottom


var lowColor = '#AEE6B1'
var highColor = '#14BC1C'

// D3 Projection
var projection = d3.geoAlbersUsa()
  .translate([width / 2, height / 2]) // translate to center of screen
  .scale([1000]); // scale things down so see entire US

// Path generator
var path = d3.geoPath() // path generator that will convert GeoJSON to SVG paths
  .projection(projection); // tell path generator to use albersUsa projection

//Dropdown 
var selectBedroom = d3.select("body").append("select")
var selectYear = d3.select("body").append("select")

//SVG element and append map to the SVG
var svg = d3.select("body")
  .append("svg")
  .attr("id", "svg")
  .attr("width", width)
  .attr("height", height);

//Map svg
var map = svg.append("svg").
	attr("id", "map")

//Tooltip
var tooltip = d3.tip()
	.attr("class", "d3-tip")
	.attr("id", "tooltip")
	.offset([0, 0])
	.style('z-index', '999999999');
	map.call(tooltip);

var timeConv = d3.timeParse("%Y-%m")
var timeConv2 = d3.timeParse("%Y-%m-%d")

var svg_linecharts = d3.select("body")
	.append("svg")
  .attr("id", "svg")
  .attr("width", 1200)
  .attr("height", 190);

// Load in my states data!
Promise.all([
  	d3.json("/visualization/us-states.json"),
  	d3.csv("/data/State_MedianRentalPrice_1Bedroom.csv"),
  	d3.csv("/data/State_MedianRentalPrice_2Bedroom.csv"),
  	d3.csv("/data/State_MedianRentalPrice_3Bedroom.csv"),
  	d3.csv("/data/State_MedianRentalPrice_4Bedroom.csv"),
  	d3.csv("/data/State_MedianRentalPrice_5BedroomOrMore.csv"),
  	d3.csv("/data/State_Zhvi_1Bedroom.csv"),
  	d3.csv("/data/State_Zhvi_2Bedroom.csv"),
  	d3.csv("/data/State_Zhvi_3Bedroom.csv"),
  	d3.csv("/data/State_Zhvi_4Bedroom.csv"),
  	d3.csv("/data/State_Zhvi_5BedroomOrMore.csv"),
  	d3.csv("/data/forecasts.csv")
	]).then(([world, one_bed, two_bed, three_bed, four_bed, five_bed,
		one_bed_zhvi, two_bed_zhvi, three_bed_zhvi, four_bed_zhvi, five_bed_zhvi, forecasts]) => {

		//Dropdown for bedroom type and year
		
		selectBedroom.attr("class", "select")
			.attr("id", "selectBedroom")
			.on("change", reColorMap);

		var roomOptions = ["1 bedroom", "2 bedrooms", "3 bedrooms", "4 bedrooms", "5 or more bedrooms"];
		selectBedroom.selectAll('option')
			.data(roomOptions)
			.enter()
			.append('option')
				.text(function (d) { return d; });

		selectYear.attr("class", "select")
			.attr("id", "selectYear")
			.on("change", reColorMap)

		var yearOptions = [2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019]

		var optionsYear = selectYear.selectAll("option")
			.data(yearOptions).enter()
			.append("option")
			.text(function(d) { return (d + ""); })

		// Dictionary to map dropdown bedroom selection to files	
		rental_dict = {"1 bedroom": one_bed, "2 bedrooms": two_bed, "3 bedrooms":three_bed, "4 bedrooms": four_bed, "5 or more bedrooms": five_bed}

		zhvi_dict = {"1 bedroom": one_bed_zhvi, "2 bedrooms": two_bed_zhvi, "3 bedrooms":three_bed_zhvi, "4 bedrooms": four_bed_zhvi, "5 or more bedrooms": five_bed_zhvi}

		//Runs choropleth map with default year = 2010, default bedrooms = 1
    reColorMap()

    //Creates linechart for historial median prices
   	function createLinechart_rental(world) {

      var linechart = svg_linecharts.append("svg")
        .attr("id", "linechart")
        .attr("width", width)
        .attr("height", lcheight + margin.bottom + 40)

      var bedroom_type = document.getElementById("selectBedroom").value

      var state = world.properties.NAME

      var data = rental_dict[bedroom_type].find(x=> x.RegionName === state)

      var data = Object.entries(data).map(([key, value]) => ({"date": key, "value": value}))

      data.forEach(function(p){
      	p.date = timeConv(p.date)
      	p.value = +p.value
      })
      data.splice(0, 3)

      var x = d3.scaleTime()
      	.domain(d3.extent(data, function(d) {return d.date}))
      	.range([0, lcwidth])

     	var y = d3.scaleLinear()
     		.domain([0, d3.max(data, function(d){return +d.value})])
     		.range([lcheight, 0])

      var g = linechart.append("g")
  			.attr("transform", "translate(" + 520 + "," + 0 + ")")

      g.append("g")
      	.call(d3.axisBottom(x))
      	.attr("transform", "translate(" + margin.left + "," + (lcheight+margin.top) + ")")

      g.append("g")
      	.call(d3.axisLeft(y))
      	.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      var lines = g.append("g")
      	.attr("id", "lines")
      	.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      lines.append("path")
      	.datum(data)
      	.attr("stroke", "black")
      	.attr("fill", "none")
      	.attr("stroke-width", 1.5)
      	.attr("d", d3.line()
      			.x(function(d) {return x(d.date)})
      			.y(function(d) {return y(d.value)})
      	)

      var area = d3.area()
		    .x(function(d) { return x(d.date); })
		    .y0(lcheight)
		    .y1(function(d) { return y(d.value); });

		  lines.append("path")
       .data([data])
       .attr("fill", "steelblue")
       .attr("d", area);

      var title = g.append("g")
		    .attr("id", "line_chart_title")
		    .attr("transform", "translate(" + (margin.left + lcwidth/2) + "," + margin.top + ")")

		  title.append("text")
		    .attr("text-anchor", "middle")
		    .style("font-size", "12px")
		    .text("Median rental prices: " + state + " - " + bedroom_type)

		  // y-axis label
      ylabel = g.append("g")
        .attr("id", "bar_y_axis_label")
        .attr("transform", "translate(" + (margin.left - 40) + "," + (margin.top + lcheight/2) + ")")

      ylabel.append("text")
        .attr("transform", "rotate(-90)")
        .text("Median rental price")
        .style("text-anchor", "middle")


      //x-axis label
      xlabel = g.append("g")
        .attr("id", "bar_x_axis_label")
        .attr("transform", "translate(" + (lcwidth/2 + margin.left) + "," + (margin.bottom + lcheight + 20) + ")")

      xlabel.append("text")
        .text("Year")
        .style("text-anchor", "middle")
    }

    function createLinechart_zhvi(world) {

      var linechart_zhvi = svg_linecharts.append("svg")
        .attr("id", "linechart2")
        .attr("width", lcwidth + margin.left)
        .attr("height", lcheight + margin.bottom + 40)
        .attr("transform", "translate(" + 600+ "," + margin.top + ")")

      
      var bedroom_type = document.getElementById("selectBedroom").value

      var state = world.properties.NAME

      var data = zhvi_dict[bedroom_type].find(x=> x.RegionName === state)

      var data = Object.entries(data).map(([key, value]) => ({"date": key, "value": value}))


      var bedroom_mapping = {"1 bedroom":"1bedroom", "2 bedrooms": "2bedroom", "3 bedrooms": "3bedroom", "4 bedrooms":"4bedroom", "5 or more bedrooms": "5bedroomOrMore"}
      
      //console.log(forecasts)
      var forecast_data = forecasts.find(x=> (x.State===state && x["Room size"] === bedroom_mapping[bedroom_type]))

      //console.log(forecast_data)

      data.forEach(function(p){
      	p.date = timeConv2(p.date)
      	p.value = +p.value
      })
      data.splice(0, 7)

      var x = d3.scaleTime()
      	.domain(d3.extent(data, function(d) {return d.date}))
      	.range([0, lcwidth])

     	var y = d3.scaleLinear()
     		.domain([0, d3.max(data, function(d){return +d.value})])
     		.range([lcheight, 0])

      var g2 = linechart_zhvi.append("g")

      g2.append("g")
      	.call(d3.axisBottom(x))
      	.attr("transform", "translate(" + margin.left + "," + (lcheight+margin.top) + ")")

      g2.append("g")
      	.call(d3.axisLeft(y))
      	.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      var lines2 = g2.append("g")
      	.attr("id", "lines")
      	.attr("transform", "translate(" + margin.left + "," + margin.top + ")")

      lines2.append("path")
      	.datum(data)
      	.attr("stroke", "black")
      	.attr("fill", "none")
      	.attr("stroke-width", 1.5)
      	.attr("d", d3.line()
      			.x(function(d) {return x(d.date)})
      			.y(function(d) {return y(d.value)})
      	)

      var area2 = d3.area()
		    .x(function(d) { return x(d.date); })
		    .y0(lcheight)
		    .y1(function(d) { return y(d.value); });

		  lines2.append("path")
       .data([data])
       .attr("fill", "#F19039")
       .attr("d", area2);

      var title2 = g2.append("g")
		    .attr("id", "line_chart_title")
		    .attr("transform", "translate(" + (margin.left + lcwidth/2) + "," + margin.top + ")")

		  title2.append("text")
		    .attr("text-anchor", "middle")
		    .style("font-size", "12px")
		    .text("Property Median Price: " + state + " - " + bedroom_type)

		  // y-axis label
      ylabel2 = g2.append("g")
        .attr("id", "bar_y_axis_label")
        .attr("transform", "translate(" + (margin.left - 40) + "," + (margin.top + lcheight/2) + ")")

      ylabel2.append("text")
        .attr("transform", "rotate(-90)")
        .text("Median rental price")
        .style("text-anchor", "middle")


      //x-axis label
      xlabel2 = g2.append("g")
        .attr("id", "bar_x_axis_label")
        .attr("transform", "translate(" + (lcwidth/2 + margin.left) + "," + (margin.bottom + lcheight + 20) + ")")

      xlabel2.append("text")
        .text("Year")
        .style("text-anchor", "middle")
    }


		function reColorMap() {
			var yearSelected = d3.select("#selectYear").property("value");
			var bedSelected = d3.select("#selectBedroom").property("value");
			file = rental_dict[bedSelected];

			file_zhvi = zhvi_dict[bedSelected]
			state_ppvalue= {}
			//console.log(file_zhvi)

			//Calculating average zhvi for each state per year
			file_zhvi.forEach(function(state_dict) {
				array = Object.entries(state_dict).map(([key, value]) => ({"date": key, "value": value}))
				array.splice(0, 6)
				year_data = []
				//Filters by year
				array.forEach(function(time_dict){
					if (time_dict.date.substring(0, 4) == yearSelected && time_dict.value != ""){
						year_data.push(time_dict.value)
					}
				})
				state_ppvalue[state_dict["RegionName"]] = d3.mean(year_data)
			})

			//Calculating median prices per state per year
			var values_dict = {};
			var dataArray = []
			for (let i = 0; i < file.length; i++) {
				var state = file[i]["RegionName"]
				var sum = 0;
				var num_entries = 0;
				var months = ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
				for (let j = 0; j < months.length; j++) {
					var check =  yearSelected + "-" + months[j];
					if (check in file[i] && file[i][check] != "") {
						sum += parseFloat(file[i][check]);
						num_entries++;
					}
				}
				var avg;
				if (num_entries == 0) {
					avg = undefined;
				} else {
					avg = sum / num_entries;
				}
				values_dict[state] = avg;
				dataArray[dataArray.length] = avg;
			}

			world.features.forEach(function(feature){
				feature.properties.value = values_dict[feature.properties.NAME]
				feature.properties.zhvi = state_ppvalue[feature.properties.NAME]
			})

			d3.selectAll("#map").remove();
			createMap(dataArray, world)
		}

		function createMap(dataArray, world){

			data_list = (world.features).map((dict) => (dict.properties.value))

			var minVal = d3.min(data_list)
			var maxVal = d3.max(data_list)
			var ramp = d3.scaleLinear().domain([minVal,maxVal]).range([lowColor,highColor])

			var map = svg.append("svg")
				.attr("id", "map")

			map.selectAll("path")
	      .data(world.features)
	      .enter()
	      .append("path")
	      .attr("d", path)
	      .style("stroke", "#fff")
	      .style("stroke-width", "1")
	      .style("fill", function(d) {
	      	if (d.properties.value == undefined){
	      		return "#808080"
	      	}
	      	else{
	      		return ramp(d.properties.value)
	      	}
	      })
	      .on("mouseover", function(d) {
	      	d3.select(this).style("fill", ramp(3*d.properties.value))
	      	createLinechart_rental(d)
	      	createLinechart_zhvi(d)

		      var x = d3.event.x,
				  y = d3.event.y;
				  var state = d.properties.NAME;
				  var value = Math.round(d.properties.value);
				  var html = "State: " + state;
				  html += "\nMedian Rental Price: " + value + "";
				  html += "\nProperty Median Price: " + Math.round(d.properties.zhvi) + "";
				  tooltip.html(html);
				  tooltip.style("top", y + "px");
				  tooltip.style("left", x + "px");
				  tooltip.show();
	      })
	      .on("mouseout", function(d){
	      	d3.select(this).style("fill", function(d){
	      		if (d.properties.value == undefined){
	      		return "#808080"
		      	}
		      	else{
		      		return ramp(d.properties.value)
		      	}
	      	})
	      	linechart.remove()
	      	linechart2.remove()
					tooltip.hide()
	      })

		  var w = 140, h = 300;

			var key = map.append("svg")
				.attr("width", w)
				.attr("height", h)
				.attr("class", "legend");

			var legend = key.append("defs")
				.append("svg:linearGradient")
				.attr("id", "gradient")
				.attr("x1", "100%")
				.attr("y1", "0%")
				.attr("x2", "100%")
				.attr("y2", "100%")
				.attr("spreadMethod", "pad");

			legend.append("stop")
				.attr("offset", "0%")
				.attr("stop-color", highColor)
				.attr("stop-opacity", 1);

			legend.append("stop")
				.attr("offset", "100%")
				.attr("stop-color", lowColor)
				.attr("stop-opacity", 1);

			key.append("rect")
				.attr("width", w - 100)
				.attr("height", h)
				.style("fill", "url(#gradient)")
				.attr("transform", "translate(0,10)");

			var y = d3.scaleLinear()
				.range([h, 0])
				.domain([minVal, maxVal]);

			var yAxis = d3.axisRight(y);

			key.append("g")
				.attr("class", "y axis")
				.attr("transform", "translate(41,10)")
				.call(yAxis)

		}

  })

</script>
</body>
</html>
